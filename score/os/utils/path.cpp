/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
///
/// @file
/// @copyright Copyright (C) 2021, Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
///

#include "score/os/utils/path.h"
#include "score/os/libgen.h"
#include "score/os/utils/path_impl.h"

/* LCOV_EXCL_START: false positive, covered by test case "get_base_name.man_page_examples" */
std::string score::os::PathImpl::get_base_name(const std::string& path) const noexcept
{
    std::string mutable_path{path};
    // FIXME: Make it RVO: broken_link_j/Ticket-139258
    // NOLINTNEXTLINE(score-no-unnamed-temporary-objects) see comment above
    return std::string{score::os::Libgen::instance().base_name(&(*mutable_path.begin()))};
}
/* LCOV_EXCL_STOP */

std::string score::os::PathImpl::get_parent_dir(const std::string& path) const noexcept
{
    std::string mutable_path{path};
    // FIXME: Make it RVO: broken_link_j/Ticket-139258
    // NOLINTNEXTLINE(score-no-unnamed-temporary-objects) see comment above
    return std::string{score::os::Libgen::instance().dirname(&(*mutable_path.begin()))};
}

score::os::Path& score::os::Path::instance() noexcept
{
    static score::os::PathImpl instance;  // LCOV_EXCL_BR_LINE
    // all branches are generated by certified compiler,
    //  no additional check necessary
    return select_instance(instance);
}

std::unique_ptr<score::os::Path> score::os::Path::Default() noexcept
{
    return std::make_unique<PathImpl>();
}
/* KW_SUPPRESS_START:MISRA.PPARAM.NEEDS.CONST, MISRA.VAR.NEEDS.CONST: */
/* score::cpp::pmr::make_unique takes non-const memory_resource */
score::cpp::pmr::unique_ptr<score::os::Path> score::os::Path::Default(score::cpp::pmr::memory_resource* memory_resource) noexcept
/* KW_SUPPRESS_END:MISRA.PPARAM.NEEDS.CONST, MISRA.VAR.NEEDS.CONST */
{
    return score::cpp::pmr::make_unique<PathImpl>(memory_resource);
}

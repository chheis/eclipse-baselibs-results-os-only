/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
#include "score/os/pthread.h"

score::os::Pthread& score::os::Pthread::instance() noexcept
{
    // suppress "AUTOSAR C++14 A3-3-2" rule finding. This rule states:
    // "Static and thread-local objects shall be constant-initialized"
    // Justification: Cannot be const initialized, singleton by design to fetch unique thread instance
    // coverity[autosar_cpp14_a3_3_2_violation]
    static const std::unique_ptr<score::os::Pthread> instance{Default()}; /* LCOV_EXCL_BR_LINE */
    /* All branches are generated by certified compiler, no additional check necessary. */
    return select_instance(*instance);
}

pthread_t score::os::Pthread::self()
{
    return ::pthread_self();
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::condattr_init(pthread_condattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of memory for pthread_condattrs. There is no way to reliably create
    // an error case in the scope of a unit test. Error is communicated via non-zero  return value. In case of an
    // error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_condattr_init(attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::condattr_setpshared(pthread_condattr_t* const attr,
                                                                          const std::int32_t pshared) const noexcept
{
    const std::int32_t ret = ::pthread_condattr_setpshared(attr, pshared);
    if (ret != 0)
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::condattr_destroy(pthread_condattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of memory for pthread_condattrs. There is no way to reliably create
    // an error case in the scope of a unit test. Error is communicated via non-zero return value. In case of an
    // error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_condattr_destroy(attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::cond_init(pthread_cond_t* const cond,
                                                                const pthread_condattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of resources for pthread_conds. There is no way to reliably create
    // an error case in the scope of a unit test. Error is communicated via non-zero return value. In case of an
    // error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_cond_init(cond, attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::cond_destroy(pthread_cond_t* const cond) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of resources for pthread_conds. There is no way to reliably create
    // an error case in the scope of a unit test. Error is communicated via non-zero return value. In case of an
    // error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_cond_destroy(cond);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::mutexattr_init(pthread_mutexattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of memory for pthread_mutexattrs. There is no way to reliably
    // create an error case in the scope of a unit test. Error is communicated via non-zero return value. In case of
    // an error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_mutexattr_init(attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::mutexattr_setpshared(pthread_mutexattr_t* const attr,
                                                                           const std::int32_t pshared) const noexcept
{
    const std::int32_t ret = ::pthread_mutexattr_setpshared(attr, pshared);
    if (ret != 0)
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::mutexattr_destroy(pthread_mutexattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of memory for pthread_mutexattrs. There is no way to reliably
    // create an error case in the scope of a unit test. Error is communicated via non-zero return value. In case of
    // an error the error code is provided by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_mutexattr_destroy(attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::mutex_init(pthread_mutex_t* const mutex,
                                                                 const pthread_mutexattr_t* const attr) const noexcept
{
    // Manual code analysis:
    // Failure only happens when system runs out of memory for pthread_mutexes, caller has insufficient permissions
    // or (optionally if) attributes are invalid. There is no way to reliably create an error case in the scope of a
    // unit test. Error is communicated via non-zero return value. In case of an error the error code is provided
    // by the return value of the function call (POSIX 1003.1).
    const std::int32_t ret = ::pthread_mutex_init(mutex, attr);
    if (ret != 0)  // LCOV_EXCL_BR_LINE
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));  // LCOV_EXCL_LINE
    }
    return {};
}

score::cpp::expected_blank<score::os::Error> score::os::Pthread::mutex_destroy(pthread_mutex_t* const mutex) const noexcept
{
    const std::int32_t ret = ::pthread_mutex_destroy(mutex);
    if (ret != 0)
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));
    }
    return {};
}
/* KW_SUPPRESS_START:MISRA.VAR.HIDDEN: it's a method definition, doesn't hide identifier in an outer scope */
score::cpp::expected_blank<score::os::Error> score::os::Pthread::pthread_setschedparam(
    /* KW_SUPPRESS_END:MISRA.VAR.HIDDEN */
    const pthread_t thread,
    const std::int32_t policy,
    const struct sched_param* const param) const noexcept
{
    const std::int32_t ret = ::pthread_setschedparam(thread, policy, param);
    if (ret != 0)
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));
    }
    return {};
}

/* KW_SUPPRESS_START:MISRA.VAR.HIDDEN: it's a method definition, doesn't hide identifier in an outer scope */
score::cpp::expected_blank<score::os::Error> score::os::Pthread::pthread_getschedparam(
    /* KW_SUPPRESS_END:MISRA.VAR.HIDDEN */
    const pthread_t thread,
    std::int32_t* const policy,
    struct sched_param* const param) const noexcept
{
    const std::int32_t ret = ::pthread_getschedparam(thread, policy, param);
    if (ret != 0)
    {
        return score::cpp::make_unexpected(Error::createFromErrno(ret));
    }
    return {};
}

/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
#include "score/os/stat_impl.h"

#include <sys/stat.h>
#include <cstdint>
#include <unordered_map>

namespace score
{
namespace os
{
namespace
{

const std::unordered_map<Stat::Mode, std::int32_t>& GetStatModesMap() noexcept
{
    /* KW_SUPPRESS_START:MISRA.USE.EXPANSION: macros unveil bit value */
    /* KW_SUPPRESS_START:MISRA.BITS.NOT_UNSIGNED: false positive, no bitwise operations */
    // suppress "AUTOSAR C++14 A3-3-2" rule finding. This rule states:
    // "Static and thread-local objects shall be constant-initialized"
    // Justification: std::map objects generally cannot be constexpr, as any dynamically allocated
    // storage must be released in the same evaluation of constant expression
    // coverity[autosar_cpp14_a3_3_2_violation]
    static const std::unordered_map<Stat::Mode, std::int32_t> mapped_modes{
        {Stat::Mode::kReadUser, S_IRUSR},
        {Stat::Mode::kWriteUser, S_IWUSR},
        {Stat::Mode::kExecUser, S_IXUSR},
        {Stat::Mode::kReadGroup, S_IRGRP},
        {Stat::Mode::kWriteGroup, S_IWGRP},
        {Stat::Mode::kExecGroup, S_IXGRP},
        {Stat::Mode::kReadOthers, S_IROTH},
        {Stat::Mode::kWriteOthers, S_IWOTH},
        {Stat::Mode::kExecOthers, S_IXOTH},
        {Stat::Mode::kSticky, S_ISVTX},
        {Stat::Mode::kSetGroupId, S_ISGID},
        {Stat::Mode::kSetUserId, S_ISUID}}; /* LCOV_EXCL_BR_LINE: Not all enumerators are mapped */

    /* KW_SUPPRESS_END:MISRA.BITS.NOT_UNSIGNED */
    /* KW_SUPPRESS_END:MISRA.USE.EXPANSION */
    return mapped_modes;
}

}  // namespace

mode_t ModeToInteger(const Stat::Mode mode) noexcept
{
    std::uint32_t native_mode{};

    const auto mode_u32 = static_cast<std::uint32_t>(mode);
    const auto& dict_modes = GetStatModesMap();
    for (const auto& item : dict_modes)
    {
        const auto stat_mode = static_cast<std::uint32_t>(item.first);
        if ((mode_u32 & stat_mode) != 0U)
        {
            const auto bit_flag = static_cast<std::uint32_t>(item.second);
            native_mode |= bit_flag;
        }
    }

    return native_mode;
}

Stat::Mode IntegerToMode(const mode_t mode) noexcept
{
    auto stat_mode_result = Stat::Mode::kNone;
    const auto mode_u32 = static_cast<std::uint32_t>(mode);
    const auto& dict_modes = GetStatModesMap();

    for (const auto& item : dict_modes)
    {
        const auto bit_flag = static_cast<std::uint32_t>(item.second);
        if ((mode_u32 & bit_flag) != 0U)
        {
            const auto stat_mode = item.first;
            stat_mode_result |= stat_mode;
        }
    }

    return stat_mode_result;
}

}  // namespace os
}  // namespace score

score::os::Stat& score::os::Stat::instance() noexcept
{
    static score::os::StatImpl instance; /* LCOV_EXCL_BR_LINE */
    /* All branches are generated by certified compiler, no additional check necessary. */
    return select_instance(instance);
}

/* KW_SUPPRESS_START:MISRA.PPARAM.NEEDS.CONST, MISRA.VAR.NEEDS.CONST: */
/* score::cpp::pmr::make_unique takes non-const memory_resource */
score::cpp::pmr::unique_ptr<score::os::Stat> score::os::Stat::Default(score::cpp::pmr::memory_resource* memory_resource) noexcept
/* KW_SUPPRESS_END:MISRA.PPARAM.NEEDS.CONST, MISRA.VAR.NEEDS.CONST */
{
    return score::cpp::pmr::make_unique<score::os::StatImpl>(memory_resource);
}

std::unique_ptr<score::os::Stat> score::os::Stat::Default() noexcept
{
    return std::make_unique<score::os::StatImpl>();
}
